section .text
    global _sort

_sort:
    mov rdx, 0  ; Используем rdx как флаг
                ; если взведен - значит не было перестановок
                ; и сортировку можно заканчивать.
                ; Иначе на новый круг
    
    mov rax, 0
_loop:          ; Бежим счетчиком rax
                ; до тех пор, пока не достигнем значения,
                ; равного длине массива. Согласно ABI
                ; первый аргумент хранится в rdi

                ; В rbx сохраняем элемент массива под индексом rax
                ; В rsi хранится второй аргумент - указатель на массив
    mov rbx, QWORD[rsi + rax * 8] ; ; (тут кстати тоже применился SIB :)
                ; Аналогично следующий
    mov rcx, QWORD[rsi + (rax + 1) * 8]
                ; Если rbx <= rcx, порядок правильный
                ; пропускаем swap
    cmp rbx, rcx
    jbe _skip_swap

    mov rdx, 1  ; взводим флаг необходимости сортировки
                ; меняем значения местами
    mov QWORD[rsi + rax * 8], rcx
    mov QWORD[rsi + (rax + 1) * 8], rbx

_skip_swap:     ; переходим сюда, если не нужно менять
                ; элементы местами
    
    add rax, 1  ; увеличиваем счетчик
                ; если не достигли конца - продолжаем цикл
    cmp rax, rdi
    jb _loop
                ; если достигли - проверяем флаг
                ; взведен => заново
    cmp rdx, 1
    je _sort

    ret
